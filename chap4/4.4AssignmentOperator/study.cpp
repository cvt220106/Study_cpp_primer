//
// Created by jacky on 2022/11/15.
//
#include <iostream>
#include <vector>

using namespace std;

int main() {
    // 赋值运算符的左侧运算对象必须是一个可修改的左值
    int i= 0, j = 0, k = 0; // 初始化并非赋值
    const int ci = i; // 初始化

    // 非法语句
//    1024 = k; // 字面值是右值，不可作为左值
//    i + j = k; // 算术表达式是右值不可做为左值
//    ci = k; // ci是常量(不可修改的)左值

    // 赋值运算的结果是它的左侧运算对象，并且是一个左值
    // 结果的类型就是左侧运算对象的类型，若左右二者运算类型不同，则右侧运算都西昂将转换乘左侧运算对象的类型
    cout << k << endl;
    k = 3.14159;
    cout << k << endl;

    // 使用{}括起的初始值列表作为赋值语句的右侧运算对象
    // 对于左侧对象为内置类型时，初始值列表最多只能包含一个值
//    k = {3.14}; // 不合法，double所占空间大于int型，初始化列表时不可以窄化处理

    // 对于类类型，赋值运算的细节由类本身决定
    vector<int> vi;
    vi = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};

    // 赋值运算满足右结合律
    int ival, jval;
    ival = jval = 0; // 合法的
    // 根据右结合律， jval先被赋值为0，再将自身的值赋值给ival
    // 多重赋值时，赋值前需要满足左右侧对象的类型相同，或右侧对象的类型可以转换为左侧对象的类型
    int ival2, *pval; // ival2类型为int，pval类型为指向int的指针
//    ival2 = pval = 0; // 不合法，不能将指针的值赋给int
    string s1, s2;
    s1 = s2 = "OK"; // 合法，字面值“OK”转换为string对象

    // 赋值运算符优先级较低
    /**
     * (i = get_value()) != 42
     * i = get_value() != 42
     * 上面两种写法有些完全不同的解释
     * 第一种情况下，括号无视优先律，先执行i得到赋值，接着再进行i与42的相等性测试
     * 第二种情况下，因为赋值运算符优先级低，因此会先进行get_value()的返回值和42进行相等性测试
     * 得到的bool值转为i的类型后赋值给i
     * 综上：条件语句中，赋值部分应该加上括号！
     */

    // 区分赋值符号= 与相等运算符==

    // 复合赋值运算符
    /**
     * += -= *= /= %= // 算术运算符
     * <<= >>= &= ^= |= // 位运算符
     * 每个复合运算符a op= b都完全等价与 a = a op b
     * 区别在于左侧对象a的求值对象
     */
}
