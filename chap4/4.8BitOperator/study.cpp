//
// Created by jacky on 2022/11/19.
//
#include <iostream>

using namespace std;

int main() {
    /**
     * 位运算符--左结合律
     * ~ 按位求反  ~expr
     * << 左移位 expr1 << expr2
     * >> 右移位 expr1 >> expr2
     * & 按位与 expr1 & expr2
     * ^ 按位异或  expr1 ^ expr2
     * | 按位或 expr1 | expr2
     * 优先律 ~ -> << >> -> & -> ^ -> |
     * 位运算符作用于整数类型，运算对象可以是有符号类型也可以时无符号类型
     * 但带符号类型中由于符号位没有明确得规定，因此位运算最好作用域无符号数
     */

    // 移位运算符 左侧对象按照右侧对象得要求进行二进制位数的移动
    // 左移运算符 << 移出的位丢弃，末尾补0
    // 右移运算符 >> 移出的位丢弃，左侧补入视对象类型，若为无符号数，步入0，有符号数补入0或符号位则看环境而定

    // 位求反运算符，将运算对象逐位求反后生成一个新值，1->0,0->1

    // 位与， 位或，位异或运算符在两个运算对象上逐位执行相应的逻辑操作
    // 位与& ，同1则1，其余为0
    // 位或|。同0则0，其余为1
    // 位异或，相同则0，不同则1

    // 使用位运算符
    /**
     * 一个班级里30名学生，每个学生每周的测验结果右通过与不通过两种状态
     * 通过一个二进制位的0，1来代表某个学生在测验中是否通过，全班的测验就可以通过一个无符号数来存储表示
     */

    unsigned quiz1 = 0; // 将quiz1作为位的集合使用，初始化所有学生都位0
    // 此时我们需要将序号位27的学生进行相应大的通过测验的设置，因此我们可以创建一个第27位为1，其余为0的值
    // 这样这个值与quiz1相或后，其他为不变，第27为变为1

    //而得到一个第27为1，其余为均为0的值，我们可以通过一个unsigned int型字面值1，移位27次后得 1u << 27;
    cout << (1u << 27) << endl;

    // 更新序号为27的学生测验通过状态
    quiz1 |= 1u << 27; // 等价于quiz1 = quiz1 | 1u << 27;

    // 若发现登记错误，序号27学生是实际并未通过测验，此时需要修改回去
    // 我们就可以通过按位与的特点，准备一个第27位位0其他位为1的数，与quiz1按位与
    // 这样quiz1除了第27位变为0，其余位不变
    // 而第27位为0其余位位1的数可以通过前面的27位为1其余位为0的数通过按位取反获得
    quiz1 &= ~(1u << 27);

    // 获取第27位同学的测验通过情况，通过与第27位为1其余位为0的数按位与获取
    bool status = quiz1 & (1u << 27);
    cout << status << endl; // 0

    // 移位运算符（IO运算符)
    // 内置符号的重载运算符的优先律和结合律不变！
    // 移位运算符满足左结合律
    cout << "hi" << " there" << endl;
    // 执行过程根据左结合律等价于( (cout << "hi") << " there" ) << endl;

    // 移位运算符的优先级介于中间，比算术运算符低，比关系运算符，赋值运算符，条件运算符优先级高
    // 因此使用<<输出时，一次使用多个运算符时，有必要在适当地方加上括号来满足优先级需求
    cout << 42 + 10 << endl; // 正确， +为算术运算优先级更高，因此会先求和再输出求和结果
    cout << (10 < 42) << endl; // 正确， 括号保证了关系运算符优先计算，再输出比较结果，符合我们的预期
//    cout << 10 < 42; // 不合法，比较运算符<优先级低于<<,因此会先将10写道cout再试图比较cout与42

}
