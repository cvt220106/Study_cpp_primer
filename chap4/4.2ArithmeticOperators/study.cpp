//
// Created by jacky on 2022/11/15.
//
#include <iostream>

using namespace std;

int main() {
    // 算术运算符支持左结合律
    // 优先律为 一元±号 -》 二元* / % -》 二元+ -号
    // 算术运算符可以作用于任意算术类型以及任意能转换为算术类型的类型
    // 算术运算符的运算对象和求职结果都是右值
    // 运算过程中会发生隐形的类型转换，最终与计算结果为同一类型

    // 一元正负号作用于对运算对象时，返回一个提升后的副本
    int i = 1024;
    int k = -i;
    cout << i << " " << k << endl;
    bool b = true;
    bool b2 = -b;
    // b2仍为true，bool值不应该参与运算
    // 这个过程中，b对应的值为1，添加负号后为-1，再转换为bool值，由于值不为0，则为真，即bool值又变为1
    cout << b << " " << b2 << endl;

    // + - * /，用于算术类型的对象是，含义就是加减乘除
    // 对于整数相除，其结果仍为整数，商中的小数部分直接抛弃！
    int ival11 = 21/6; // 3,抛弃小数部分或者说抛弃了余数部分
    int ival12 = 21/7; // 整除，无余数
    cout << ival11 << " " << ival12 << endl;

    // % 取余/取模运算符，负责计算两个整数相除所得的余数
    // 参与取余的运算对象必须是整数类型
    int ival = 42;
    double dval = 3.14;
    cout << ival % 12 << endl;
//    cout << ival % dval << endl; // 不合法，运算对象为浮点数

    // 除法与取模运算中的负号处理方法
    // 对于除法，除了两个运算对象符号相同时商为正，其他情况下均为负
    // 下面三者形式相同
    cout << (-42)/5 << " " << 42/(-5) << " " << -(42/5) << endl;

    // 对于取余时这种情况就不同
    // 对于余数的正负，如果余数不为0，则余数的符号与被除数相同,即m%n中的m
    cout << 21 % 6 << " " << 21 % (-6) << " " << (-21) % 6 << " " << (-21) % (-6) << endl;
    // 3 3 -3 -3
}